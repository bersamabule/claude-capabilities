# Spec-to-Implementation Bridge - Spec Scanner

Detect and catalog all specification files in the codebase.

## Usage

`/spec-scan` - Scan for all spec files
`/spec-scan:openapi` - Only OpenAPI/Swagger specs
`/spec-scan:graphql` - Only GraphQL schemas
`/spec-scan:database` - Only database schemas (Prisma, TypeORM, etc.)
`/spec-scan:proto` - Only Protocol Buffers

## Instructions

### Step 1: Detect Spec Files

Search for specification files using these patterns:

| Spec Type | File Patterns | Content Markers |
|-----------|---------------|-----------------|
| **OpenAPI** | `*.yaml`, `*.yml`, `*.json` | `openapi:`, `swagger:`, `"openapi"`, `"swagger"` |
| **GraphQL** | `*.graphql`, `*.gql`, `schema.graphql` | `type Query`, `type Mutation`, `schema {` |
| **Prisma** | `schema.prisma`, `*.prisma` | `model `, `datasource `, `generator ` |
| **TypeORM** | `*.entity.ts`, `entities/*.ts` | `@Entity()`, `@Column()` |
| **Protocol Buffers** | `*.proto` | `syntax = "proto`, `message `, `service ` |
| **JSON Schema** | `*.schema.json`, `schemas/*.json` | `"$schema"`, `"type"`, `"properties"` |
| **AsyncAPI** | `asyncapi.yaml`, `asyncapi.json` | `asyncapi:`, `"asyncapi"` |
| **Database Migrations** | `migrations/`, `db/migrate/` | SQL files, migration scripts |

### Step 2: Analyze Each Spec

For each spec found, extract:

```markdown
### [Spec Name]

**Type**: OpenAPI / GraphQL / Prisma / etc.
**File**: `path/to/spec.yaml`
**Version**: (if applicable)

#### Contents Summary
- **Endpoints/Types/Models**: [count]
- **Operations**: [list key operations]
- **Data Models**: [list key models]

#### Implementation Status
- **Generated Code**: [paths to generated files if any]
- **Manual Implementations**: [paths to hand-written implementations]
- **Coverage**: [estimated % of spec implemented]
```

### Step 3: Check for Existing Generators

Look for code generation configuration:

| Generator | Config Files |
|-----------|--------------|
| OpenAPI Generator | `openapitools.json`, `.openapi-generator/` |
| GraphQL Codegen | `codegen.yml`, `codegen.ts`, `graphql.config.js` |
| Prisma | `schema.prisma` (generates client) |
| protoc | `buf.yaml`, `buf.gen.yaml`, Makefile with protoc |
| orval | `orval.config.ts` |
| swagger-typescript-api | `swagger-typescript-api.config.js` |

### Step 4: Map Spec to Implementation

For each spec, find corresponding implementation:

**OpenAPI → Code Mapping**:
```
/api/users (GET) → src/routes/users.ts:getUsers()
/api/users (POST) → src/routes/users.ts:createUser()
/api/users/{id} (GET) → src/routes/users.ts:getUserById()
```

**GraphQL → Code Mapping**:
```
Query.users → src/resolvers/users.ts:users()
Mutation.createUser → src/resolvers/users.ts:createUser()
type User → src/types/User.ts
```

**Prisma → Code Mapping**:
```
model User → Generated: node_modules/.prisma/client
model User → Used in: src/services/userService.ts
```

### Step 5: Generate Report

Create `docs/specs/README.md`:

```markdown
# Specification Inventory

> Generated by Spec-to-Implementation Bridge
> Last scanned: [DATE]

## Summary

| Spec Type | Count | Coverage |
|-----------|-------|----------|
| OpenAPI | [X] | [Y%] |
| GraphQL | [X] | [Y%] |
| Database | [X] | [Y%] |
| Total | [X] | [Y%] |

---

## Specifications Found

### OpenAPI Specs

#### [spec-name.yaml]
- **Path**: `api/openapi.yaml`
- **Version**: 3.0.3
- **Endpoints**: 15
- **Models**: 8
- **Generator**: openapi-generator-cli
- **Generated Output**: `src/generated/api/`
- **Coverage**: 100% (all endpoints implemented)

[Continue for each spec...]

---

## Implementation Map

| Spec Element | Implementation | Status |
|--------------|----------------|--------|
| `GET /users` | `src/routes/users.ts:12` | Implemented |
| `POST /users` | `src/routes/users.ts:45` | Implemented |
| `User` schema | `src/types/User.ts:5` | Implemented |
| `GET /orders` | - | Missing |

---

## Recommendations

### Missing Implementations
- [ ] `GET /orders` endpoint not found
- [ ] `Order` schema has no TypeScript type

### Outdated Implementations
- [ ] `User` type missing new `avatar` field from spec

### Generator Suggestions
- Consider using [generator] for [spec] to automate code generation
```

### Step 6: Store Spec Registry

Create `docs/specs/registry.json` for programmatic access:

```json
{
  "lastScanned": "2025-12-15T10:30:00Z",
  "specs": [
    {
      "type": "openapi",
      "path": "api/openapi.yaml",
      "version": "3.0.3",
      "endpoints": 15,
      "models": 8,
      "generator": "openapi-generator-cli",
      "generatedOutput": "src/generated/api/",
      "coverage": 100
    }
  ],
  "mappings": [
    {
      "specElement": "GET /users",
      "specFile": "api/openapi.yaml",
      "implementation": "src/routes/users.ts:12",
      "status": "implemented"
    }
  ]
}
```

## Output Format

```markdown
## Spec Scan Results

Scanned [X] files, found [Y] specifications.

### Specifications Found

| Type | File | Elements | Coverage |
|------|------|----------|----------|
| OpenAPI | `api/openapi.yaml` | 15 endpoints, 8 models | 93% |
| GraphQL | `schema.graphql` | 12 queries, 5 mutations | 100% |
| Prisma | `prisma/schema.prisma` | 10 models | 100% |

### Quick Actions

- `/spec-drift` - Check for drift between specs and implementation
- `/spec-generate [spec]` - Generate code from a spec
- `/spec-validate [spec]` - Validate spec file

### Detailed Report

Saved to: `docs/specs/README.md`
```

## Integration

- **Knowledge Graph**: Adds spec-to-implementation relationships
- **PR Reviewer**: Checks PRs for spec compliance
- **Technical Debt Radar**: Flags spec drift as debt
- **Chronicle**: Records spec scan results
